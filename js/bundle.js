/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/FABRIK.js":
/*!***********************!*\
  !*** ./src/FABRIK.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ref: http://wiki.roblox.com/index.php?title=Inverse_kinematics#FABRIK\n\nclass FABRIK {\n\n\tconstructor(jointsRef, targetRef, options = {}) {\n\n\t\tconst isTargetRefNull = targetRef === null || targetRef === undefined;\n\t\tif (isTargetRefNull) {\n\n\t\t\ttargetRef = new THREE.Object3D();\n\t\t\ttargetRef.position.copy(jointsRef[jointsRef.length - 1].getWorldPosition());\n\t\t}\n\n\t\tconst _joints = jointsRef.map(j => {\n\n\t\t\tconst pos = j.getWorldPosition();\n\t\t\tconst obj = new THREE.Vector3().copy(pos);\n\t\t\treturn obj;\n\t\t});\n\n\t\tconst _target = targetRef.getWorldPosition();\n\n\t\tconst lengths = _joints.reduce((carry, v1, idx, arr) => {\n\n\t\t\tconst v0 = arr[idx - 1];\n\t\t\tif (v0) {\n\n\t\t\t\tcarry.push(v1.distanceTo(v0));\n\t\t\t}\n\n\t\t\treturn carry;\n\t\t}, []);\n\n\t\tthis.refs = {};\n\t\tthis.refs.target = targetRef;\n\t\tthis.refs.joints = jointsRef;\n\t\tthis.refs.visualizers = _joints.map(j => {\n\n\t\t\tconst obj = new THREE.AxesHelper(1);\n\t\t\tobj.position.copy(j);\n\t\t\treturn obj;\n\t\t});\n\t\tconst _targetVis = new THREE.AxesHelper(2);\n\t\t_targetVis.position.copy(_target);\n\t\tthis.refs.visualizers.push(_targetVis);\n\n\t\tthis.n = _joints.length;\n\t\tthis.tolerance = 0.01;\n\n\t\tthis.target = _target;\n\n\t\tthis.joints = _joints;\n\t\tthis.origin = _joints[0].clone();\n\n\t\tthis.lengths = lengths;\n\t\tthis.totalLength = lengths.reduce((c, l) => c + l);\n\n\t\t// constraints\n\n\t\tthis.constraints = {};\n\n\t\tthis.constraints.enabled = false;\n\t\tthis.constraints.left = this.constraints.right = this.constraints.top = this.constraints.down = THREE.Math.degToRad(89);\n\n\t\treturn this;\n\t}\n\n\tvisualize(scene) {\n\n\t\tif (scene) this.refs.visualizers.forEach(v => scene.add(v));\n\n\t\tthis.refs.visualizers.forEach((v, index) => {\n\n\t\t\tif (index === this.n) {\n\n\t\t\t\tv.position.copy(this.target);\n\t\t\t\tv.rotation.copy(this.refs.target.rotation);\n\t\t\t} else {\n\n\t\t\t\tv.position.copy(this.joints[index]);\n\t\t\t\tv.rotation.copy(this.refs.joints[index].rotation);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tapply(lerpAlpha = 0.8) {\n\n\t\tthis.refs.joints.forEach((j, i) => {\n\n\t\t\tlet v = this.joints[i + 1] || this.target;\n\t\t\tconst localChildPosition = j.parent.worldToLocal(v.clone());\n\t\t\tconst q = j.quaternion.clone();\n\t\t\tj.lookAt(localChildPosition);\n\t\t\tj.rotateY(3.14159);\n\t\t\tj.quaternion.slerp(q, 1 - lerpAlpha);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tsolve() {\n\n\t\t// get target reference's position\n\t\tthis.target.copy(this.refs.target.getWorldPosition());\n\n\t\t// distance\n\t\tconst vector = new THREE.Vector3().subVectors(this.target, this.joints[0]);\n\t\tconst distance = vector.length();\n\t\tconst outOfRange = distance > this.totalLength;\n\n\t\tif (outOfRange) {\n\n\t\t\tlet a = 0;\n\n\t\t\tconst v = vector.clone().normalize().multiplyScalar(this.totalLength);\n\n\t\t\tthis.joints.forEach((joint, index) => {\n\n\t\t\t\tif (index === 0) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ta += this.lengths[index - 1] / this.totalLength;\n\n\t\t\t\tjoint.addVectors(this.joints[0], v.clone().multiplyScalar(a));\n\t\t\t});\n\t\t} else {\n\n\t\t\tlet count = 0;\n\t\t\tlet diff = this.joints[this.n - 1].distanceTo(this.target);\n\n\t\t\twhile (diff > this.tolerance && count < 2) {\n\n\t\t\t\tthis.backward();\n\t\t\t\tthis.forward();\n\t\t\t\tdiff = this.joints[this.n - 1].distanceTo(this.target);\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\tbackward() {\n\n\t\tthis.joints[this.n - 1].copy(this.target);\n\n\t\tconst min = 0;\n\t\tfor (let i = this.n - 2; i >= min; i--) {\n\n\t\t\tconst r = this.joints[i + 1].distanceTo(this.joints[i]);\n\t\t\tconst l = this.lengths[i] / r;\n\t\t\tconst pos = this.joints[i + 1].clone().multiplyScalar(1 - l).add(this.joints[i].clone().multiplyScalar(l));\n\n\t\t\tthis.joints[i].copy(pos);\n\t\t}\n\n\t\treturn this;\n\t}\n\tforward() {\n\n\t\tthis.joints[0].copy(this.origin);\n\n\t\tconst max = this.n - 2;\n\t\tfor (let i = 0; i <= max; i++) {\n\n\t\t\tconst r = this.joints[i + 1].distanceTo(this.joints[i]);\n\t\t\tconst l = this.lengths[i] / r;\n\n\t\t\tconst pos = this.joints[i].clone().multiplyScalar(1 - l).add(this.joints[i + 1].clone().multiplyScalar(l));\n\n\t\t\tthis.joints[i + 1].copy(pos);\n\t\t}\n\n\t\treturn this;\n\t}\n\trefresh() {\n\n\t\tthis.refs.joints.forEach((j, i) => {\n\n\t\t\tconst pos = j.getWorldPosition();\n\t\t\tthis.joints[i].copy(pos);\n\t\t});\n\t\tthis.origin = this.joints[0].clone();\n\t\tthis.target = this.refs.target.getWorldPosition();\n\t}\n\tconstrain(calc, cone) {\n\n\t\t// calc : calculated of result form FABRIK algorithm\n\t\t// line : cone's center axis\n\t\t// cone : the cone matrix\n\n\t\tconst line = new THREE.Vector3(0, 0, 1).applyMatrix4(cone);\n\t\tconst scalar = calc.dot(line) / line.length();\n\t\tconst proj = line.clone().normalize().multiplyScalar(scalar);\n\n\t\t// get axis that are closest\n\t\tconst ups = [new THREE.Vector3(0, 1, 0).applyMatrix4(cone), new THREE.Vector3(0, -1, 0).applyMatrix4(cone)];\n\t\tconst downs = [new THREE.Vector3(1, 0, 0).applyMatrix4(cone), new THREE.Vector3(-1, 0, 0).applyMatrix4(cone)];\n\n\t\tconst sortFn = (a, b) => {\n\n\t\t\tconst _a = a.clone().sub(calc).length();\n\t\t\tconst _b = b.clone().sub(calc).length();\n\t\t\treturn _a - _b;\n\t\t};\n\t\tconst upvec = ups.sort(sortFn)[0];\n\t\tconst rightvec = downs.sort(sortFn)[0];\n\n\t\t// get the vector from the projection to the calculated vector\n\t\tconst adjust = new THREE.Vector3().subVectors(calc, proj);\n\t\tscalar < 0 && proj.negate();\n\n\t\t// get the 2D components\n\t\tconst xaspect = adjust.dot(rightvec);\n\t\tconst yaspect = adjust.dot(upvec);\n\n\t\t// get the cross section of the cone\n\t\tconst left = -proj.length() * Math.tan(this.constraints.left);\n\t\tconst right = proj.length() * Math.tan(this.constraints.right);\n\t\tconst up = proj.length() * Math.tan(this.constraints.top);\n\t\tconst down = -proj.length() * Math.tan(this.constraints.down);\n\n\t\t// find the quadrant\n\t\tconst xbound = xaspect >= 0 && right || left;\n\t\tconst ybound = yaspect >= 0 && up || down;\n\n\t\tconst f = calc.clone();\n\n\t\t// check if in 2D point lies in the ellipse\n\t\tconst ellipse = Math.pow(xaspect, 2) / Math.pow(xbound, 2) + Math.pow(yaspect, 2) / Math.pow(ybound, 2);\n\t\tconst inbounds = ellipse <= 1 && scalar >= 0;\n\n\t\tif (!inbounds) {\n\n\t\t\t// get the angle of our out of ellipse point\n\t\t\tconst a = Math.atan2(yaspect, xaspect);\n\t\t\t// find the nearest point\n\t\t\tconst x = xbound * Math.cos(a);\n\t\t\tconst y = ybound * Math.sin(a);\n\t\t\t// convert back to 3D\n\t\t\tf.copy(proj.clone().add(rightvec.clone().multiplyScalar(x)).add(upvec.clone().multiplyScalar(y)).normalize().multiplyScalar(calc.length()));\n\t\t}\n\n\t\treturn f;\n\t}\n\n}\n\nTHREE.FABRIK = FABRIK;\n\n//# sourceURL=webpack:///./src/FABRIK.js?");

/***/ }),

/***/ "./src/GLTFLoader.js":
/*!***************************!*\
  !*** ./src/GLTFLoader.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nTHREE.GLTFLoader = function () {\n\n\tfunction GLTFLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t}\n\n\tGLTFLoader.prototype = {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function (url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\n\t\t\tloader.setResponseType('arraybuffer');\n\n\t\t\tloader.load(url, function (data) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse(data, path, onLoad, onError);\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tif (onError !== undefined) {\n\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tsetCrossOrigin: function (value) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\t},\n\n\t\tsetPath: function (value) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\t},\n\n\t\tparse: function (data, path, onLoad, onError) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\n\t\t\tif (typeof data === 'string') {\n\n\t\t\t\tcontent = data;\n\t\t\t} else {\n\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n\t\t\t\tif (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n\t\t\t\t\t} catch (error) {\n\n\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar json = JSON.parse(content);\n\n\t\t\tif (json.asset === undefined || json.asset.version[0] < 2) {\n\n\t\t\t\tif (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (json.extensionsUsed) {\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_LIGHTS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_LIGHTS] = new GLTFLightsExtension(json);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.time('GLTFLoader');\n\n\t\t\tvar parser = new GLTFParser(json, extensions, {\n\n\t\t\t\tpath: path || this.path || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\tmanager: this.manager\n\n\t\t\t});\n\n\t\t\tparser.parse(function (scene, scenes, cameras, animations, asset) {\n\n\t\t\t\tconsole.timeEnd('GLTFLoader');\n\n\t\t\t\tvar glTF = {\n\t\t\t\t\tscene: scene,\n\t\t\t\t\tscenes: scenes,\n\t\t\t\t\tcameras: cameras,\n\t\t\t\t\tanimations: animations,\n\t\t\t\t\tasset: asset\n\t\t\t\t};\n\n\t\t\t\tonLoad(glTF);\n\t\t\t}, onError);\n\t\t}\n\n\t};\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn {\n\n\t\t\tget: function (key) {\n\n\t\t\t\treturn objects[key];\n\t\t\t},\n\n\t\t\tadd: function (key, object) {\n\n\t\t\t\tobjects[key] = object;\n\t\t\t},\n\n\t\t\tremove: function (key) {\n\n\t\t\t\tdelete objects[key];\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\t\t\t}\n\n\t\t};\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_LIGHTS: 'KHR_lights',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness'\n\t};\n\n\t/**\n  * Lights Extension\n  *\n  * Specification: PENDING\n  */\n\tfunction GLTFLightsExtension(json) {\n\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS;\n\n\t\tthis.lights = {};\n\n\t\tvar extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS] || {};\n\t\tvar lights = extension.lights || {};\n\n\t\tfor (var lightId in lights) {\n\n\t\t\tvar light = lights[lightId];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color().fromArray(light.color);\n\n\t\t\tswitch (light.type) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight(color);\n\t\t\t\t\tlightNode.position.set(0, 0, 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight(color);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight(color);\n\t\t\t\t\tlightNode.position.set(0, 0, 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlightNode = new THREE.AmbientLight(color);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (lightNode) {\n\n\t\t\t\tif (light.constantAttenuation !== undefined) {\n\n\t\t\t\t\tlightNode.intensity = light.constantAttenuation;\n\t\t\t\t}\n\n\t\t\t\tif (light.linearAttenuation !== undefined) {\n\n\t\t\t\t\tlightNode.distance = 1 / light.linearAttenuation;\n\t\t\t\t}\n\n\t\t\t\tif (light.quadraticAttenuation !== undefined) {\n\n\t\t\t\t\tlightNode.decay = light.quadraticAttenuation;\n\t\t\t\t}\n\n\t\t\t\tif (light.fallOffAngle !== undefined) {\n\n\t\t\t\t\tlightNode.angle = light.fallOffAngle;\n\t\t\t\t}\n\n\t\t\t\tif (light.fallOffExponent !== undefined) {\n\n\t\t\t\t\tconsole.warn('THREE.GLTFLoader:: light.fallOffExponent not currently supported.');\n\t\t\t\t}\n\n\t\t\t\tlightNode.name = light.name || 'light_' + lightId;\n\t\t\t\tthis.lights[lightId] = lightNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* BINARY EXTENSION */\n\n\tvar BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension(data) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n\n\t\tthis.header = {\n\t\t\tmagic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n\t\t\tversion: headerView.getUint32(4, true),\n\t\t\tlength: headerView.getUint32(8, true)\n\t\t};\n\n\t\tif (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n\t\t} else if (this.header.version < 2.0) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n\t\t}\n\n\t\tvar chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n\t\tvar chunkIndex = 0;\n\n\t\twhile (chunkIndex < chunkView.byteLength) {\n\n\t\t\tvar chunkLength = chunkView.getUint32(chunkIndex, true);\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32(chunkIndex, true);\n\t\t\tchunkIndex += 4;\n\n\t\t\tif (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n\n\t\t\t\tvar contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText(contentArray);\n\t\t\t} else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice(byteOffset, byteOffset + chunkLength);\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\t\t}\n\n\t\tif (this.content === null) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: JSON content not found.');\n\t\t}\n\t}\n\n\t/**\n  * Specular-Glossiness Extension\n  *\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n  */\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn THREE.ShaderMaterial;\n\t\t\t},\n\n\t\t\textendParams: function (params, material, parser) {\n\n\t\t\t\tvar pbrSpecularGlossiness = material.extensions[this.name];\n\n\t\t\t\tvar shader = THREE.ShaderLib['standard'];\n\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t\t\tvar specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n\n\t\t\t\tvar glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n\n\t\t\t\tvar specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n\n\t\t\t\tvar glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n\n\t\t\t\tvar lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n\n\t\t\t\tvar fragmentShader = shader.fragmentShader.replace('#include <specularmap_fragment>', '').replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n\n\t\t\t\tdelete uniforms.roughness;\n\t\t\t\tdelete uniforms.metalness;\n\t\t\t\tdelete uniforms.roughnessMap;\n\t\t\t\tdelete uniforms.metalnessMap;\n\n\t\t\t\tuniforms.specular = { value: new THREE.Color().setHex(0x111111) };\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\n\t\t\t\tuniforms.specularMap = { value: null };\n\t\t\t\tuniforms.glossinessMap = { value: null };\n\n\t\t\t\tparams.vertexShader = shader.vertexShader;\n\t\t\t\tparams.fragmentShader = fragmentShader;\n\t\t\t\tparams.uniforms = uniforms;\n\t\t\t\tparams.defines = { 'STANDARD': '' };\n\n\t\t\t\tparams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\t\t\tparams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tparams.color.fromArray(array);\n\t\t\t\t\tparams.opacity = array[3];\n\t\t\t\t}\n\n\t\t\t\tif (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture.index));\n\t\t\t\t}\n\n\t\t\t\tparams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n\t\t\t\tparams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tparams.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n\t\t\t\tif (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n\n\t\t\t\t\tparams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n\t\t\t\t}\n\n\t\t\t\tif (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n\n\t\t\t\t\tvar specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'glossinessMap', specGlossIndex));\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'specularMap', specGlossIndex));\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all(pending);\n\t\t\t},\n\n\t\t\tcreateMaterial: function (params) {\n\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n\t\t\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\t\tdefines: params.defines,\n\t\t\t\t\tvertexShader: params.vertexShader,\n\t\t\t\t\tfragmentShader: params.fragmentShader,\n\t\t\t\t\tuniforms: params.uniforms,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tlights: true,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\ttransparent: params.transparent\n\t\t\t\t});\n\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tmaterial.color = params.color;\n\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = params.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\t\t\t\tif (params.normalScale) material.normalScale = params.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\n\t\t\t\tmaterial.specular = params.specular;\n\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n\t\t\t\tmaterial.glossiness = params.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\tmaterial.extensions.derivatives = true;\n\n\t\t\t\treturn material;\n\t\t\t},\n\n\t\t\t/**\n    * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n    * copy only properties it knows about or inherits, and misses many properties that would\n    * normally be defined by MeshStandardMaterial.\n    *\n    * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n    * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n    * AND also updating `.onBeforeRender` on the parent mesh.\n    *\n    * @param  {THREE.ShaderMaterial} source\n    * @return {THREE.ShaderMaterial}\n    */\n\t\t\tcloneMaterial: function (source) {\n\n\t\t\t\tvar target = source.clone();\n\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tvar params = this.specularGlossinessParams;\n\n\t\t\t\tfor (var i = 0, il = params.length; i < il; i++) {\n\n\t\t\t\t\ttarget[params[i]] = source[params[i]];\n\t\t\t\t}\n\n\t\t\t\treturn target;\n\t\t\t},\n\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n\t\t\trefreshUniforms: function (renderer, scene, camera, geometry, material, group) {\n\n\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial !== true) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tvar defines = material.defines;\n\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\t\tuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\n\t\t\t\tvar uvScaleMap;\n\n\t\t\t\tif (material.map) {\n\n\t\t\t\t\tuvScaleMap = material.map;\n\t\t\t\t} else if (material.specularMap) {\n\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\t\t\t} else if (material.displacementMap) {\n\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\t\t\t} else if (material.normalMap) {\n\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\t\t\t} else if (material.bumpMap) {\n\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\t\t\t} else if (material.glossinessMap) {\n\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\n\t\t\t\t} else if (material.alphaMap) {\n\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t\t} else if (material.emissiveMap) {\n\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\t\t\t}\n\n\t\t\t\tif (uvScaleMap !== undefined) {\n\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif (uvScaleMap.isWebGLRenderTarget) {\n\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset;\n\t\t\t\t\tvar repeat;\n\n\t\t\t\t\tif (uvScaleMap.matrix !== undefined) {\n\n\t\t\t\t\t\t// > r88.\n\n\t\t\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\n\t\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\t\t\t\t\t\t\tvar rotation = uvScaleMap.rotation;\n\t\t\t\t\t\t\tvar center = uvScaleMap.center;\n\n\t\t\t\t\t\t\tuvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// <= r87. Remove when reasonable.\n\n\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\n\t\t\t\t\t\tuniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t\tuniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1;\n\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tuniforms.specular.value.copy(material.specular);\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\n\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\tif (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\n\t\t\t\t}\n\n\t\t\t\tif (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\n\t\tTHREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = (t - t0) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s0 = 2 * ppp - 3 * pp + 1;\n\t\tvar s1 = ppp - 2 * pp + p;\n\t\tvar s2 = -2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor (var i = 0; i !== stride; i++) {\n\n\t\t\tvar p0 = values[offset0 + i + stride]; // splineVertex_k\n\t\t\tvar m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\t\t\tvar m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_TYPE = {\n\t\t5126: Number,\n\t\t//35674: THREE.Matrix2,\n\t\t35675: THREE.Matrix3,\n\t\t35676: THREE.Matrix4,\n\t\t35664: THREE.Vector2,\n\t\t35665: THREE.Vector3,\n\t\t35666: THREE.Vector4,\n\t\t35678: THREE.Texture\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: THREE.NearestFilter,\n\t\t9729: THREE.LinearFilter,\n\t\t9984: THREE.NearestMipMapNearestFilter,\n\t\t9985: THREE.LinearMipMapNearestFilter,\n\t\t9986: THREE.NearestMipMapLinearFilter,\n\t\t9987: THREE.LinearMipMapLinearFilter\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t10497: THREE.RepeatWrapping\n\t};\n\n\tvar WEBGL_TEXTURE_FORMATS = {\n\t\t6406: THREE.AlphaFormat,\n\t\t6407: THREE.RGBFormat,\n\t\t6408: THREE.RGBAFormat,\n\t\t6409: THREE.LuminanceFormat,\n\t\t6410: THREE.LuminanceAlphaFormat\n\t};\n\n\tvar WEBGL_TEXTURE_DATATYPES = {\n\t\t5121: THREE.UnsignedByteType,\n\t\t32819: THREE.UnsignedShort4444Type,\n\t\t32820: THREE.UnsignedShort5551Type,\n\t\t33635: THREE.UnsignedShort565Type\n\t};\n\n\tvar WEBGL_SIDES = {\n\t\t1028: THREE.BackSide, // Culling front\n\t\t1029: THREE.FrontSide // Culling back\n\t\t//1032: THREE.NoSide   // Culling front and back, what to do?\n\t};\n\n\tvar WEBGL_DEPTH_FUNCS = {\n\t\t512: THREE.NeverDepth,\n\t\t513: THREE.LessDepth,\n\t\t514: THREE.EqualDepth,\n\t\t515: THREE.LessEqualDepth,\n\t\t516: THREE.GreaterEqualDepth,\n\t\t517: THREE.NotEqualDepth,\n\t\t518: THREE.GreaterEqualDepth,\n\t\t519: THREE.AlwaysDepth\n\t};\n\n\tvar WEBGL_BLEND_EQUATIONS = {\n\t\t32774: THREE.AddEquation,\n\t\t32778: THREE.SubtractEquation,\n\t\t32779: THREE.ReverseSubtractEquation\n\t};\n\n\tvar WEBGL_BLEND_FUNCS = {\n\t\t0: THREE.ZeroFactor,\n\t\t1: THREE.OneFactor,\n\t\t768: THREE.SrcColorFactor,\n\t\t769: THREE.OneMinusSrcColorFactor,\n\t\t770: THREE.SrcAlphaFactor,\n\t\t771: THREE.OneMinusSrcAlphaFactor,\n\t\t772: THREE.DstAlphaFactor,\n\t\t773: THREE.OneMinusDstAlphaFactor,\n\t\t774: THREE.DstColorFactor,\n\t\t775: THREE.OneMinusDstColorFactor,\n\t\t776: THREE.SrcAlphaSaturateFactor\n\t\t// The followings are not supported by Three.js yet\n\t\t//32769: CONSTANT_COLOR,\n\t\t//32770: ONE_MINUS_CONSTANT_COLOR,\n\t\t//32771: CONSTANT_ALPHA,\n\t\t//32772: ONE_MINUS_CONSTANT_COLOR\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\n\t\t// KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\n\t\t// using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\n\t\t// See KeyframeTrack.optimize() for the detail.\n\t\tLINEAR: THREE.InterpolateLinear,\n\t\tSTEP: THREE.InterpolateDiscrete\n\t};\n\n\tvar STATES_ENABLES = {\n\t\t2884: 'CULL_FACE',\n\t\t2929: 'DEPTH_TEST',\n\t\t3042: 'BLEND',\n\t\t3089: 'SCISSOR_TEST',\n\t\t32823: 'POLYGON_OFFSET_FILL',\n\t\t32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL(url, path) {\n\n\t\t// Invalid URL\n\t\tif (typeof url !== 'string' || url === '') return '';\n\n\t\t// Absolute URL http://,https://,//\n\t\tif (/^(https?:)?\\/\\//i.test(url)) return url;\n\n\t\t// Data URI\n\t\tif (/^data:.*,.*$/i.test(url)) return url;\n\n\t\t// Blob URL\n\t\tif (/^blob:.*$/i.test(url)) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n  */\n\tfunction createDefaultMaterial() {\n\n\t\treturn new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: THREE.FrontSide\n\t\t});\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n  *\n  * TODO: Implement support for morph targets on TANGENT attribute.\n  *\n  * @param {THREE.Mesh} mesh\n  * @param {GLTF.Mesh} meshDef\n  * @param {GLTF.Primitive} primitiveDef\n  * @param {Array<THREE.BufferAttribute>} accessors\n  */\n\tfunction addMorphTargets(mesh, meshDef, primitiveDef, accessors) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar material = mesh.material;\n\n\t\tvar targets = primitiveDef.targets;\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tmorphAttributes.position = [];\n\t\tmorphAttributes.normal = [];\n\n\t\tmaterial.morphTargets = true;\n\n\t\tfor (var i = 0, il = targets.length; i < il; i++) {\n\n\t\t\tvar target = targets[i];\n\t\t\tvar attributeName = 'morphTarget' + i;\n\n\t\t\tvar positionAttribute, normalAttribute;\n\n\t\t\tif (target.POSITION !== undefined) {\n\n\t\t\t\t// Three.js morph formula is\n\t\t\t\t//   position\n\t\t\t\t//     + weight0 * ( morphTarget0 - position )\n\t\t\t\t//     + weight1 * ( morphTarget1 - position )\n\t\t\t\t//     ...\n\t\t\t\t// while the glTF one is\n\t\t\t\t//   position\n\t\t\t\t//     + weight0 * morphTarget0\n\t\t\t\t//     + weight1 * morphTarget1\n\t\t\t\t//     ...\n\t\t\t\t// then adding position to morphTarget.\n\t\t\t\t// So morphTarget value will depend on mesh's position, then cloning attribute\n\t\t\t\t// for the case if attribute is shared among two or more meshes.\n\n\t\t\t\tpositionAttribute = cloneBufferAttribute(accessors[target.POSITION]);\n\t\t\t\tvar position = geometry.attributes.position;\n\n\t\t\t\tfor (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n\n\t\t\t\t\tpositionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n\t\t\t\t}\n\t\t\t} else if (geometry.attributes.position) {\n\n\t\t\t\t// Copying the original position not to affect the final position.\n\t\t\t\t// See the formula above.\n\t\t\t\tpositionAttribute = cloneBufferAttribute(geometry.attributes.position);\n\t\t\t}\n\n\t\t\tif (positionAttribute !== undefined) {\n\n\t\t\t\tpositionAttribute.name = attributeName;\n\t\t\t\tmorphAttributes.position.push(positionAttribute);\n\t\t\t}\n\n\t\t\tif (target.NORMAL !== undefined) {\n\n\t\t\t\tmaterial.morphNormals = true;\n\n\t\t\t\t// see target.POSITION's comment\n\n\t\t\t\tnormalAttribute = cloneBufferAttribute(accessors[target.NORMAL]);\n\t\t\t\tvar normal = geometry.attributes.normal;\n\n\t\t\t\tfor (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n\n\t\t\t\t\tnormalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n\t\t\t\t}\n\t\t\t} else if (geometry.attributes.normal !== undefined) {\n\n\t\t\t\tnormalAttribute = cloneBufferAttribute(geometry.attributes.normal);\n\t\t\t}\n\n\t\t\tif (normalAttribute !== undefined) {\n\n\t\t\t\tnormalAttribute.name = attributeName;\n\t\t\t\tmorphAttributes.normal.push(normalAttribute);\n\t\t\t}\n\t\t}\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif (meshDef.weights !== undefined) {\n\n\t\t\tfor (var i = 0, il = meshDef.weights.length; i < il; i++) {\n\n\t\t\t\tmesh.morphTargetInfluences[i] = meshDef.weights[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isPrimitiveEqual(a, b) {\n\n\t\tif (a.indices !== b.indices) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tvar attribA = a.attributes || {};\n\t\tvar attribB = b.attributes || {};\n\t\tvar keysA = Object.keys(attribA);\n\t\tvar keysB = Object.keys(attribB);\n\n\t\tif (keysA.length !== keysB.length) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (var i = 0, il = keysA.length; i < il; i++) {\n\n\t\t\tvar key = keysA[i];\n\n\t\t\tif (attribA[key] !== attribB[key]) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction getCachedGeometry(cache, newPrimitive) {\n\n\t\tfor (var i = 0, il = cache.length; i < il; i++) {\n\n\t\t\tvar cached = cache[i];\n\n\t\t\tif (isPrimitiveEqual(cached.primitive, newPrimitive)) {\n\n\t\t\t\treturn cached.geometry;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction cloneBufferAttribute(attribute) {\n\n\t\tif (attribute.isInterleavedBufferAttribute) {\n\n\t\t\tvar count = attribute.count;\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar array = attribute.array.slice(0, count * itemSize);\n\n\t\t\tfor (var i = 0; i < count; ++i) {\n\n\t\t\t\tarray[i] = attribute.getX(i);\n\t\t\t\tif (itemSize >= 2) array[i + 1] = attribute.getY(i);\n\t\t\t\tif (itemSize >= 3) array[i + 2] = attribute.getZ(i);\n\t\t\t\tif (itemSize >= 4) array[i + 3] = attribute.getW(i);\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n\t\t}\n\n\t\treturn attribute.clone();\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser(json, extensions, options) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = extensions || {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = [];\n\n\t\tthis.textureLoader = new THREE.TextureLoader(this.options.manager);\n\t\tthis.textureLoader.setCrossOrigin(this.options.crossOrigin);\n\n\t\tthis.fileLoader = new THREE.FileLoader(this.options.manager);\n\t\tthis.fileLoader.setResponseType('arraybuffer');\n\t}\n\n\tGLTFParser.prototype.parse = function (onLoad, onError) {\n\n\t\tvar json = this.json;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis.markDefs();\n\n\t\t// Fire the callback on complete\n\t\tthis.getMultiDependencies(['scene', 'animation', 'camera']).then(function (dependencies) {\n\n\t\t\tvar scenes = dependencies.scenes || [];\n\t\t\tvar scene = scenes[json.scene || 0];\n\t\t\tvar animations = dependencies.animations || [];\n\t\t\tvar asset = json.asset;\n\t\t\tvar cameras = dependencies.cameras || [];\n\n\t\t\tonLoad(scene, scenes, cameras, animations, asset);\n\t\t}).catch(onError);\n\t};\n\n\t/**\n  * Marks the special nodes/meshes in json for efficient parse.\n  */\n\tGLTFParser.prototype.markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\tvar meshReferences = {};\n\t\tvar meshUses = {};\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n\n\t\t\tvar joints = skinDefs[skinIndex].joints;\n\n\t\t\tfor (var i = 0, il = joints.length; i < il; i++) {\n\n\t\t\t\tnodeDefs[joints[i]].isBone = true;\n\t\t\t}\n\t\t}\n\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t// references and rename instances below.\n\t\t//\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\tfor (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n\n\t\t\tvar nodeDef = nodeDefs[nodeIndex];\n\n\t\t\tif (nodeDef.mesh !== undefined) {\n\n\t\t\t\tif (meshReferences[nodeDef.mesh] === undefined) {\n\n\t\t\t\t\tmeshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n\t\t\t\t}\n\n\t\t\t\tmeshReferences[nodeDef.mesh]++;\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif (nodeDef.skin !== undefined) {\n\n\t\t\t\t\tmeshDefs[nodeDef.mesh].isSkinnedMesh = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.json.meshReferences = meshReferences;\n\t\tthis.json.meshUses = meshUses;\n\t};\n\n\t/**\n  * Requests the specified dependency asynchronously, with caching.\n  * @param {string} type\n  * @param {number} index\n  * @return {Promise<Object>}\n  */\n\tGLTFParser.prototype.getDependency = function (type, index) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get(cacheKey);\n\n\t\tif (!dependency) {\n\n\t\t\tvar fnName = 'load' + type.charAt(0).toUpperCase() + type.slice(1);\n\t\t\tdependency = this[fnName](index);\n\t\t\tthis.cache.add(cacheKey, dependency);\n\t\t}\n\n\t\treturn dependency;\n\t};\n\n\t/**\n  * Requests all dependencies of the specified type asynchronously, with caching.\n  * @param {string} type\n  * @return {Promise<Array<Object>>}\n  */\n\tGLTFParser.prototype.getDependencies = function (type) {\n\n\t\tvar dependencies = this.cache.get(type);\n\n\t\tif (!dependencies) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n\n\t\t\tdependencies = Promise.all(defs.map(function (def, index) {\n\n\t\t\t\treturn parser.getDependency(type, index);\n\t\t\t}));\n\n\t\t\tthis.cache.add(type, dependencies);\n\t\t}\n\n\t\treturn dependencies;\n\t};\n\n\t/**\n  * Requests all multiple dependencies of the specified types asynchronously, with caching.\n  * @param {Array<string>} types\n  * @return {Promise<Object<Array<Object>>>}\n  */\n\tGLTFParser.prototype.getMultiDependencies = function (types) {\n\n\t\tvar results = {};\n\t\tvar pendings = [];\n\n\t\tfor (var i = 0, il = types.length; i < il; i++) {\n\n\t\t\tvar type = types[i];\n\t\t\tvar value = this.getDependencies(type);\n\n\t\t\tvalue = value.then(function (key, value) {\n\n\t\t\t\tresults[key] = value;\n\t\t\t}.bind(this, type + (type === 'mesh' ? 'es' : 's')));\n\n\t\t\tpendings.push(value);\n\t\t}\n\n\t\treturn Promise.all(pendings).then(function () {\n\n\t\t\treturn results;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n  * @param {number} bufferIndex\n  * @return {Promise<ArrayBuffer>}\n  */\n\tGLTFParser.prototype.loadBuffer = function (bufferIndex) {\n\n\t\tvar bufferDef = this.json.buffers[bufferIndex];\n\t\tvar loader = this.fileLoader;\n\n\t\tif (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif (bufferDef.uri === undefined && bufferIndex === 0) {\n\n\t\t\treturn Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise(function (resolve, reject) {\n\n\t\t\tloader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n\n\t\t\t\treject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n  * @param {number} bufferViewIndex\n  * @return {Promise<ArrayBuffer>}\n  */\n\tGLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[bufferViewIndex];\n\n\t\treturn this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n  * @param {number} accessorIndex\n  * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n  */\n\tGLTFParser.prototype.loadAccessor = function (accessorIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[accessorIndex];\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif (accessorDef.bufferView !== undefined) {\n\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n\t\t} else {\n\n\t\t\tpendingBufferViews.push(null);\n\t\t}\n\n\t\tif (accessorDef.sparse !== undefined) {\n\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n\t\t}\n\n\t\treturn Promise.all(pendingBufferViews).then(function (bufferViews) {\n\n\t\t\tvar bufferView = bufferViews[0];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = json.bufferViews[accessorDef.bufferView].byteStride;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif (byteStride && byteStride !== itemBytes) {\n\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n\t\t\t\tvar ib = parser.cache.get(ibCacheKey);\n\n\t\t\t\tif (!ib) {\n\n\t\t\t\t\t// Use the full buffer if it's interleaved.\n\t\t\t\t\tarray = new TypedArray(bufferView);\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n\n\t\t\t\t\tparser.cache.add(ibCacheKey, ib);\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);\n\t\t\t} else {\n\n\t\t\t\tif (bufferView === null) {\n\n\t\t\t\t\tarray = new TypedArray(accessorDef.count * itemSize);\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif (accessorDef.sparse !== undefined) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n\t\t\t\tvar sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n\t\t\t\tif (bufferView !== null) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute.setArray(bufferAttribute.array.slice());\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, il = sparseIndices.length; i < il; i++) {\n\n\t\t\t\t\tvar index = sparseIndices[i];\n\n\t\t\t\t\tbufferAttribute.setX(index, sparseValues[i * itemSize]);\n\t\t\t\t\tif (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n\t\t\t\t\tif (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n\t\t\t\t\tif (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n\t\t\t\t\tif (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n  * @param {number} textureIndex\n  * @return {Promise<THREE.Texture>}\n  */\n\tGLTFParser.prototype.loadTexture = function (textureIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureLoader = this.textureLoader;\n\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tvar textureDef = json.textures[textureIndex];\n\t\tvar source = json.images[textureDef.source];\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\n\t\tif (source.bufferView !== undefined) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob([bufferView], { type: source.mimeType });\n\t\t\t\tsourceURI = URL.createObjectURL(blob);\n\t\t\t\treturn sourceURI;\n\t\t\t});\n\t\t}\n\n\t\treturn Promise.resolve(sourceURI).then(function (sourceURI) {\n\n\t\t\t// Load Texture resource.\n\n\t\t\tvar loader = THREE.Loader.Handlers.get(sourceURI) || textureLoader;\n\n\t\t\treturn new Promise(function (resolve, reject) {\n\n\t\t\t\tloader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n\t\t\t});\n\t\t}).then(function (texture) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif (isObjectURL === true) {\n\n\t\t\t\tURL.revokeObjectURL(sourceURI);\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif (textureDef.name !== undefined) texture.name = textureDef.name;\n\n\t\t\ttexture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[textureDef.format] : THREE.RGBAFormat;\n\n\t\t\tif (textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[textureDef.internalFormat]) {\n\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');\n\t\t\t}\n\n\t\t\ttexture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[textureDef.type] : THREE.UnsignedByteType;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[textureDef.sampler] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n\n\t\t\treturn texture;\n\t\t});\n\t};\n\n\t/**\n  * Asynchronously assigns a texture to the given material parameters.\n  * @param {Object} materialParams\n  * @param {string} textureName\n  * @param {number} textureIndex\n  * @return {Promise}\n  */\n\tGLTFParser.prototype.assignTexture = function (materialParams, textureName, textureIndex) {\n\n\t\treturn this.getDependency('texture', textureIndex).then(function (texture) {\n\n\t\t\tmaterialParams[textureName] = texture;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n  * @param {number} materialIndex\n  * @return {Promise<THREE.Material>}\n  */\n\tGLTFParser.prototype.loadMaterial = function (materialIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = this.json.materials[materialIndex];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n\n\t\t\tvar sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n\t\t\tmaterialType = sgExtension.getMaterialType(materialDef);\n\t\t\tpending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n\t\t} else if (materialDef.pbrMetallicRoughness !== undefined) {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray(array);\n\t\t\t\tmaterialParams.opacity = array[3];\n\t\t\t}\n\n\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif (metallicRoughness.metallicRoughnessTexture !== undefined) {\n\n\t\t\t\tvar textureIndex = metallicRoughness.metallicRoughnessTexture.index;\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'metalnessMap', textureIndex));\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'roughnessMap', textureIndex));\n\t\t\t}\n\t\t} else {\n\n\t\t\tmaterialType = THREE.MeshPhongMaterial;\n\t\t}\n\n\t\tif (materialDef.doubleSided === true) {\n\n\t\t\tmaterialParams.side = THREE.DoubleSide;\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif (alphaMode === ALPHA_MODES.BLEND) {\n\n\t\t\tmaterialParams.transparent = true;\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif (alphaMode === ALPHA_MODES.MASK) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.normalTexture !== undefined) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture.index));\n\n\t\t\tmaterialParams.normalScale = new THREE.Vector2(1, 1);\n\n\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\n\t\t\t\tmaterialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.occlusionTexture !== undefined) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture.index));\n\n\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.emissiveFactor !== undefined) {\n\n\t\t\tif (materialType === THREE.MeshBasicMaterial) {\n\n\t\t\t\tmaterialParams.color = new THREE.Color().fromArray(materialDef.emissiveFactor);\n\t\t\t} else {\n\n\t\t\t\tmaterialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.emissiveTexture !== undefined) {\n\n\t\t\tif (materialType === THREE.MeshBasicMaterial) {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', materialDef.emissiveTexture.index));\n\t\t\t} else {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture.index));\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all(pending).then(function () {\n\n\t\t\tvar material;\n\n\t\t\tif (materialType === THREE.ShaderMaterial) {\n\n\t\t\t\tmaterial = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType(materialParams);\n\t\t\t}\n\n\t\t\tif (materialDef.name !== undefined) material.name = materialDef.name;\n\n\t\t\t// Normal map textures use OpenGL conventions:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\n\t\t\tif (material.normalScale) {\n\n\t\t\t\tmaterial.normalScale.x = -material.normalScale.x;\n\t\t\t}\n\n\t\t\t// emissiveTexture and baseColorTexture use sRGB encoding.\n\t\t\tif (material.map) material.map.encoding = THREE.sRGBEncoding;\n\t\t\tif (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\n\t\t\tif (materialDef.extras) material.userData = materialDef.extras;\n\n\t\t\treturn material;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n  * @param {Array<Object>} primitives\n  * @return {Promise<Array<THREE.BufferGeometry>>}\n  */\n\tGLTFParser.prototype.loadGeometries = function (primitives) {\n\n\t\tvar cache = this.primitiveCache;\n\n\t\treturn this.getDependencies('accessor').then(function (accessors) {\n\n\t\t\tvar geometries = [];\n\n\t\t\tfor (var i = 0, il = primitives.length; i < il; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = getCachedGeometry(cache, primitive);\n\n\t\t\t\tif (cached) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tgeometries.push(cached);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tvar attributes = primitive.attributes;\n\n\t\t\t\t\tfor (var attributeId in attributes) {\n\n\t\t\t\t\t\tvar attributeEntry = attributes[attributeId];\n\n\t\t\t\t\t\tvar bufferAttribute = accessors[attributeEntry];\n\n\t\t\t\t\t\tswitch (attributeId) {\n\n\t\t\t\t\t\t\tcase 'POSITION':\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('position', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'NORMAL':\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('normal', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD_0':\n\t\t\t\t\t\t\tcase 'TEXCOORD0':\n\t\t\t\t\t\t\tcase 'TEXCOORD':\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('uv', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD_1':\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('uv2', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'COLOR_0':\n\t\t\t\t\t\t\tcase 'COLOR0':\n\t\t\t\t\t\t\tcase 'COLOR':\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('color', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'WEIGHTS_0':\n\t\t\t\t\t\t\tcase 'WEIGHT':\n\t\t\t\t\t\t\t\t// WEIGHT semantic deprecated.\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('skinWeight', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'JOINTS_0':\n\t\t\t\t\t\t\tcase 'JOINT':\n\t\t\t\t\t\t\t\t// JOINT semantic deprecated.\n\n\t\t\t\t\t\t\t\tgeometry.addAttribute('skinIndex', bufferAttribute);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (primitive.indices !== undefined) {\n\n\t\t\t\t\t\tgeometry.setIndex(accessors[primitive.indices]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache.push({\n\n\t\t\t\t\t\tprimitive: primitive,\n\t\t\t\t\t\tgeometry: geometry\n\n\t\t\t\t\t});\n\n\t\t\t\t\tgeometries.push(geometry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometries;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n  * @param {number} meshIndex\n  * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n  */\n\tGLTFParser.prototype.loadMesh = function (meshIndex) {\n\n\t\tvar scope = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = this.json.meshes[meshIndex];\n\n\t\treturn this.getMultiDependencies(['accessor', 'material']).then(function (dependencies) {\n\n\t\t\tvar group = new THREE.Group();\n\n\t\t\tvar primitives = meshDef.primitives;\n\n\t\t\treturn scope.loadGeometries(primitives).then(function (geometries) {\n\n\t\t\t\tfor (var i = 0, il = primitives.length; i < il; i++) {\n\n\t\t\t\t\tvar primitive = primitives[i];\n\t\t\t\t\tvar geometry = geometries[i];\n\n\t\t\t\t\tvar material = primitive.material === undefined ? createDefaultMaterial() : dependencies.materials[primitive.material];\n\n\t\t\t\t\tif (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n\n\t\t\t\t\t\tconsole.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n\t\t\t\t\t\tgeometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the material will be modified later on, clone it now.\n\t\t\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\t\t\tvar useSkinning = meshDef.isSkinnedMesh === true;\n\t\t\t\t\tvar useMorphTargets = primitive.targets !== undefined;\n\n\t\t\t\t\tif (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n\n\t\t\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial) {\n\n\t\t\t\t\t\t\tvar specGlossExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n\t\t\t\t\t\t\tmaterial = specGlossExtension.cloneMaterial(material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = material.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useVertexColors) {\n\n\t\t\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useFlatShading) {\n\n\t\t\t\t\t\tmaterial.flatShading = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n\n\t\t\t\t\t\tif (useSkinning) {\n\n\t\t\t\t\t\t\tmesh = new THREE.SkinnedMesh(geometry, material);\n\t\t\t\t\t\t\tmaterial.skinning = true;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleStripDrawMode;\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleFanDrawMode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINES || primitive.mode === WEBGL_CONSTANTS.LINE_STRIP || primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n\n\t\t\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar lineMaterial = scope.cache.get(cacheKey);\n\n\t\t\t\t\t\tif (!lineMaterial) {\n\n\t\t\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(lineMaterial, material);\n\t\t\t\t\t\t\tlineMaterial.color.copy(material.color);\n\t\t\t\t\t\t\tlineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add(cacheKey, lineMaterial);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.LINES) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments(geometry, material);\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Line(geometry, material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineLoop(geometry, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n\n\t\t\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar pointsMaterial = scope.cache.get(cacheKey);\n\n\t\t\t\t\t\tif (!pointsMaterial) {\n\n\t\t\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(pointsMaterial, material);\n\t\t\t\t\t\t\tpointsMaterial.color.copy(material.color);\n\t\t\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\t\t\tpointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add(cacheKey, pointsMaterial);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t\t\t\tmesh = new THREE.Points(geometry, material);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || 'mesh_' + meshIndex;\n\n\t\t\t\t\tif (useMorphTargets) {\n\n\t\t\t\t\t\taddMorphTargets(mesh, meshDef, primitive, dependencies.accessors);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meshDef.extras !== undefined) mesh.userData = meshDef.extras;\n\t\t\t\t\tif (primitive.extras !== undefined) mesh.geometry.userData = primitive.extras;\n\n\t\t\t\t\t// for Specular-Glossiness.\n\t\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\tmesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (primitives.length > 1) {\n\n\t\t\t\t\t\tmesh.name += '_' + i;\n\n\t\t\t\t\t\tgroup.add(mesh);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn mesh;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n  * @param {number} cameraIndex\n  * @return {Promise<THREE.Camera>}\n  */\n\tGLTFParser.prototype.loadCamera = function (cameraIndex) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[cameraIndex];\n\t\tvar params = cameraDef[cameraDef.type];\n\n\t\tif (!params) {\n\n\t\t\tconsole.warn('THREE.GLTFLoader: Missing camera parameters.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (cameraDef.type === 'perspective') {\n\n\t\t\tvar aspectRatio = params.aspectRatio || 1;\n\t\t\tvar xfov = params.yfov * aspectRatio;\n\n\t\t\tcamera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(xfov), aspectRatio, params.znear || 1, params.zfar || 2e6);\n\t\t} else if (cameraDef.type === 'orthographic') {\n\n\t\t\tcamera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n\t\t}\n\n\t\tif (cameraDef.name !== undefined) camera.name = cameraDef.name;\n\t\tif (cameraDef.extras) camera.userData = cameraDef.extras;\n\n\t\treturn Promise.resolve(camera);\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n  * @param {number} skinIndex\n  * @return {Promise<Object>}\n  */\n\tGLTFParser.prototype.loadSkin = function (skinIndex) {\n\n\t\tvar skinDef = this.json.skins[skinIndex];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif (skinDef.inverseBindMatrices === undefined) {\n\n\t\t\treturn Promise.resolve(skinEntry);\n\t\t}\n\n\t\treturn this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n  * @param {number} animationIndex\n  * @return {Promise<THREE.AnimationClip>}\n  */\n\tGLTFParser.prototype.loadAnimation = function (animationIndex) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = this.json.animations[animationIndex];\n\n\t\treturn this.getMultiDependencies(['accessor', 'node']).then(function (dependencies) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor (var i = 0, il = animationDef.channels.length; i < il; i++) {\n\n\t\t\t\tvar channel = animationDef.channels[i];\n\t\t\t\tvar sampler = animationDef.samplers[channel.sampler];\n\n\t\t\t\tif (sampler) {\n\n\t\t\t\t\tvar target = channel.target;\n\t\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n\t\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n\n\t\t\t\t\tvar inputAccessor = dependencies.accessors[input];\n\t\t\t\t\tvar outputAccessor = dependencies.accessors[output];\n\n\t\t\t\t\tvar node = dependencies.nodes[name];\n\n\t\t\t\t\tif (node) {\n\n\t\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\t\tswitch (PATH_PROPERTIES[target.path]) {\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n\n\t\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\t\tif (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n\n\t\t\t\t\t\t\t// node should be THREE.Group here but\n\t\t\t\t\t\t\t// PATH_PROPERTIES.weights(morphTargetInfluences) should be\n\t\t\t\t\t\t\t// the property of a mesh object under node.\n\t\t\t\t\t\t\t// So finding targets here.\n\n\t\t\t\t\t\t\tnode.traverse(function (object) {\n\n\t\t\t\t\t\t\t\tif (object.isMesh === true && object.material.morphTargets === true) {\n\n\t\t\t\t\t\t\t\t\ttargetNames.push(object.name ? object.name : object.uuid);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttargetNames.push(targetName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\n\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\n\t\t\t\t\t\t// be reused by other tracks, make copies here.\n\t\t\t\t\t\tfor (var j = 0, jl = targetNames.length; j < jl; j++) {\n\n\t\t\t\t\t\t\tvar track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation);\n\n\t\t\t\t\t\t\t// Here is the trick to enable custom interpolation.\n\t\t\t\t\t\t\t// Overrides .createInterpolant in a factory method which creates custom interpolation.\n\t\t\t\t\t\t\tif (sampler.interpolation === 'CUBICSPLINE') {\n\n\t\t\t\t\t\t\t\ttrack.createInterpolant = function (result) {\n\n\t\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttracks.push(track);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new THREE.AnimationClip(name, undefined, tracks);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n  * @param {number} nodeIndex\n  * @return {Promise<THREE.Object3D>}\n  */\n\tGLTFParser.prototype.loadNode = function (nodeIndex) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshReferences = this.json.meshReferences;\n\t\tvar meshUses = this.json.meshUses;\n\n\t\tvar nodeDef = this.json.nodes[nodeIndex];\n\n\t\treturn this.getMultiDependencies(['mesh', 'skin', 'camera']).then(function (dependencies) {\n\n\t\t\tvar node;\n\n\t\t\tif (nodeDef.isBone === true) {\n\n\t\t\t\tnode = new THREE.Bone();\n\t\t\t} else if (nodeDef.mesh !== undefined) {\n\n\t\t\t\tvar mesh = dependencies.meshes[nodeDef.mesh];\n\n\t\t\t\tnode = mesh.clone();\n\n\t\t\t\t// for Specular-Glossiness\n\t\t\t\tif (mesh.isGroup === true) {\n\n\t\t\t\t\tfor (var i = 0, il = mesh.children.length; i < il; i++) {\n\n\t\t\t\t\t\tvar child = mesh.children[i];\n\n\t\t\t\t\t\tif (child.material && child.material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\t\tnode.children[i].onBeforeRender = child.onBeforeRender;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (meshReferences[nodeDef.mesh] > 1) {\n\n\t\t\t\t\tnode.name += '_instance_' + meshUses[nodeDef.mesh]++;\n\t\t\t\t}\n\t\t\t} else if (nodeDef.camera !== undefined) {\n\n\t\t\t\tnode = dependencies.cameras[nodeDef.camera];\n\t\t\t} else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n\n\t\t\t\tvar lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n\t\t\t\tnode = lights[nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light];\n\t\t\t} else {\n\n\t\t\t\tnode = new THREE.Object3D();\n\t\t\t}\n\n\t\t\tif (nodeDef.name !== undefined) {\n\n\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n\t\t\t}\n\n\t\t\tif (nodeDef.extras) node.userData = nodeDef.extras;\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.fromArray(nodeDef.matrix);\n\t\t\t\tnode.applyMatrix(matrix);\n\t\t\t} else {\n\n\t\t\t\tif (nodeDef.translation !== undefined) {\n\n\t\t\t\t\tnode.position.fromArray(nodeDef.translation);\n\t\t\t\t}\n\n\t\t\t\tif (nodeDef.rotation !== undefined) {\n\n\t\t\t\t\tnode.quaternion.fromArray(nodeDef.rotation);\n\t\t\t\t}\n\n\t\t\t\tif (nodeDef.scale !== undefined) {\n\n\t\t\t\t\tnode.scale.fromArray(nodeDef.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n  * @param {number} sceneIndex\n  * @return {Promise<THREE.Scene>}\n  */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy(nodeId, parentObject, json, allNodes, skins) {\n\n\t\t\tvar node = allNodes[nodeId];\n\t\t\tvar nodeDef = json.nodes[nodeId];\n\n\t\t\t// build skeleton here as well\n\n\t\t\tif (nodeDef.skin !== undefined) {\n\n\t\t\t\tvar meshes = node.isGroup === true ? node.children : [node];\n\n\t\t\t\tfor (var i = 0, il = meshes.length; i < il; i++) {\n\n\t\t\t\t\tvar mesh = meshes[i];\n\t\t\t\t\tvar skinEntry = skins[nodeDef.skin];\n\n\t\t\t\t\tvar bones = [];\n\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\tfor (var j = 0, jl = skinEntry.joints.length; j < jl; j++) {\n\n\t\t\t\t\t\tvar jointId = skinEntry.joints[j];\n\t\t\t\t\t\tvar jointNode = allNodes[jointId];\n\n\t\t\t\t\t\tif (jointNode) {\n\n\t\t\t\t\t\t\tbones.push(jointNode);\n\n\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\tif (skinEntry.inverseBindMatrices !== undefined) {\n\n\t\t\t\t\t\t\t\tmat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboneInverses.push(mat);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', jointId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build node hierachy\n\n\t\t\tparentObject.add(node);\n\n\t\t\tif (nodeDef.children) {\n\n\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\tfor (var i = 0, il = children.length; i < il; i++) {\n\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tbuildNodeHierachy(child, node, json, allNodes, skins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn function loadScene(sceneIndex) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[sceneIndex];\n\n\t\t\treturn this.getMultiDependencies(['node', 'skin']).then(function (dependencies) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tif (sceneDef.name !== undefined) scene.name = sceneDef.name;\n\n\t\t\t\tif (sceneDef.extras) scene.userData = sceneDef.extras;\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tfor (var i = 0, il = nodeIds.length; i < il; i++) {\n\n\t\t\t\t\tbuildNodeHierachy(nodeIds[i], scene, json, dependencies.nodes, dependencies.skins);\n\t\t\t\t}\n\n\t\t\t\t// Ambient lighting, if present, is always attached to the scene root.\n\t\t\t\tif (sceneDef.extensions && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS] && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n\n\t\t\t\t\tvar lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n\t\t\t\t\tscene.add(lights[sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light]);\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\t\t\t});\n\t\t};\n\t}();\n\n\treturn GLTFLoader;\n}();\n\n//# sourceURL=webpack:///./src/GLTFLoader.js?");

/***/ }),

/***/ "./src/OrbitControls.js":
/*!******************************!*\
  !*** ./src/OrbitControls.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls = function (object, domElement) {\n\n\tthis.object = object;\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = -Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.25;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn spherical.phi;\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn spherical.theta;\n\t};\n\n\tthis.reset = function () {\n\n\t\tscope.target.copy(scope.target0);\n\t\tscope.object.position.copy(scope.position0);\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent(changeEvent);\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\t};\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n\t\tvar quatInverse = quat.clone().inverse();\n\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\treturn function update() {\n\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy(position).sub(scope.target);\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion(quat);\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3(offset);\n\n\t\t\tif (scope.autoRotate && state === STATE.NONE) {\n\n\t\t\t\trotateLeft(getAutoRotationAngle());\n\t\t\t}\n\n\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n\n\t\t\tspherical.makeSafe();\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n\n\t\t\t// move target to panned location\n\t\t\tscope.target.add(panOffset);\n\n\t\t\toffset.setFromSpherical(spherical);\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion(quatInverse);\n\n\t\t\tposition.copy(scope.target).add(offset);\n\n\t\t\tscope.object.lookAt(scope.target);\n\n\t\t\tif (scope.enableDamping === true) {\n\n\t\t\t\tsphericalDelta.theta *= 1 - scope.dampingFactor;\n\t\t\t\tsphericalDelta.phi *= 1 - scope.dampingFactor;\n\t\t\t} else {\n\n\t\t\t\tsphericalDelta.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tscale = 1;\n\t\t\tpanOffset.set(0, 0, 0);\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\n\t\t\t\tlastPosition.copy(scope.object.position);\n\t\t\t\tlastQuaternion.copy(scope.object.quaternion);\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\t}();\n\n\tthis.dispose = function () {\n\n\t\tscope.domElement.removeEventListener('contextmenu', onContextMenu, false);\n\t\tscope.domElement.removeEventListener('mousedown', onMouseDown, false);\n\t\tscope.domElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tscope.domElement.removeEventListener('touchstart', onTouchStart, false);\n\t\tscope.domElement.removeEventListener('touchend', onTouchEnd, false);\n\t\tscope.domElement.removeEventListener('touchmove', onTouchMove, false);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\twindow.removeEventListener('keydown', onKeyDown, false);\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tvar STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow(0.95, scope.zoomSpeed);\n\t}\n\n\tfunction rotateLeft(angle) {\n\n\t\tsphericalDelta.theta -= angle;\n\t}\n\n\tfunction rotateUp(angle) {\n\n\t\tsphericalDelta.phi -= angle;\n\t}\n\n\tvar panLeft = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panLeft(distance, objectMatrix) {\n\n\t\t\tv.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\t\t\tv.multiplyScalar(-distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t}();\n\n\tvar panUp = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panUp(distance, objectMatrix) {\n\n\t\t\tv.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix\n\t\t\tv.multiplyScalar(distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t}();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\treturn function pan(deltaX, deltaY) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif (scope.object instanceof THREE.PerspectiveCamera) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy(position).sub(scope.target);\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\tpanLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t\tpanUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t} else if (scope.object instanceof THREE.OrthographicCamera) {\n\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n\t\t\t\tpanUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\t\t\t\tscope.enablePan = false;\n\t\t\t}\n\t\t};\n\t}();\n\n\tfunction dollyIn(dollyScale) {\n\n\t\tif (scope.object instanceof THREE.PerspectiveCamera) {\n\n\t\t\tscale /= dollyScale;\n\t\t} else if (scope.object instanceof THREE.OrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\tfunction dollyOut(dollyScale) {\n\n\t\tif (scope.object instanceof THREE.PerspectiveCamera) {\n\n\t\t\tscale *= dollyScale;\n\t\t} else if (scope.object instanceof THREE.OrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate(event) {\n\n\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\trotateStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownDolly(event) {\n\n\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\tdollyStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownPan(event) {\n\n\t\t//console.log( 'handleMouseDownPan' );\n\n\t\tpanStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseMoveRotate(event) {\n\n\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\trotateEnd.set(event.clientX, event.clientY);\n\t\trotateDelta.subVectors(rotateEnd, rotateStart);\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t// rotating across whole screen goes 360 degrees around\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMoveDolly(event) {\n\n\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\tdollyEnd.set(event.clientX, event.clientY);\n\n\t\tdollyDelta.subVectors(dollyEnd, dollyStart);\n\n\t\tif (dollyDelta.y > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t} else if (dollyDelta.y < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t}\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMovePan(event) {\n\n\t\t//console.log( 'handleMouseMovePan' );\n\n\t\tpanEnd.set(event.clientX, event.clientY);\n\n\t\tpanDelta.subVectors(panEnd, panStart);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseUp(event) {\n\n\t\t//console.log( 'handleMouseUp' );\n\n\t}\n\n\tfunction handleMouseWheel(event) {\n\n\t\t//console.log( 'handleMouseWheel' );\n\n\t\tif (event.deltaY < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t} else if (event.deltaY > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t}\n\n\t\tscope.update();\n\t}\n\n\tfunction handleKeyDown(event) {\n\n\t\t//console.log( 'handleKeyDown' );\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan(0, scope.keyPanSpeed);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan(0, -scope.keyPanSpeed);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan(scope.keyPanSpeed, 0);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan(-scope.keyPanSpeed, 0);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction handleTouchStartRotate(event) {\n\n\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\trotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\t}\n\n\tfunction handleTouchStartDolly(event) {\n\n\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tdollyStart.set(0, distance);\n\t}\n\n\tfunction handleTouchStartPan(event) {\n\n\t\t//console.log( 'handleTouchStartPan' );\n\n\t\tpanStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\t}\n\n\tfunction handleTouchMoveRotate(event) {\n\n\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\trotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\trotateDelta.subVectors(rotateEnd, rotateStart);\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t// rotating across whole screen goes 360 degrees around\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchMoveDolly(event) {\n\n\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tdollyEnd.set(0, distance);\n\n\t\tdollyDelta.subVectors(dollyEnd, dollyStart);\n\n\t\tif (dollyDelta.y > 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t} else if (dollyDelta.y < 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t}\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchMovePan(event) {\n\n\t\t//console.log( 'handleTouchMovePan' );\n\n\t\tpanEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\tpanDelta.subVectors(panEnd, panStart);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchEnd(event) {}\n\n\t//console.log( 'handleTouchEnd' );\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\n\tfunction onMouseDown(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tif (event.button === scope.mouseButtons.ORBIT) {\n\n\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\thandleMouseDownRotate(event);\n\n\t\t\tstate = STATE.ROTATE;\n\t\t} else if (event.button === scope.mouseButtons.ZOOM) {\n\n\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\thandleMouseDownDolly(event);\n\n\t\t\tstate = STATE.DOLLY;\n\t\t} else if (event.button === scope.mouseButtons.PAN) {\n\n\t\t\tif (scope.enablePan === false) return;\n\n\t\t\thandleMouseDownPan(event);\n\n\t\t\tstate = STATE.PAN;\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tdocument.addEventListener('mousemove', onMouseMove, false);\n\t\t\tdocument.addEventListener('mouseup', onMouseUp, false);\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tif (state === STATE.ROTATE) {\n\n\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\thandleMouseMoveRotate(event);\n\t\t} else if (state === STATE.DOLLY) {\n\n\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\thandleMouseMoveDolly(event);\n\t\t} else if (state === STATE.PAN) {\n\n\t\t\tif (scope.enablePan === false) return;\n\n\t\t\thandleMouseMovePan(event);\n\t\t}\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleMouseUp(event);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\n\t\tif (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\thandleMouseWheel(event);\n\n\t\tscope.dispatchEvent(startEvent); // not sure why these are here...\n\t\tscope.dispatchEvent(endEvent);\n\t}\n\n\tfunction onKeyDown(event) {\n\n\t\tif (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n\t\thandleKeyDown(event);\n\t}\n\n\tfunction onTouchStart(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t// one-fingered touch: rotate\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchStartRotate(event);\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// two-fingered touch: dolly\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleTouchStartDolly(event);\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t// three-fingered touch: pan\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleTouchStartPan(event);\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onTouchMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t// one-fingered touch: rotate\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_ROTATE) return; // is this needed?...\n\n\t\t\t\thandleTouchMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// two-fingered touch: dolly\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_DOLLY) return; // is this needed?...\n\n\t\t\t\thandleTouchMoveDolly(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t// three-fingered touch: pan\n\n\t\t\t\tif (scope.enablePan === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_PAN) return; // is this needed?...\n\n\t\t\t\thandleTouchMovePan(event);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\t}\n\n\tfunction onTouchEnd(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleTouchEnd(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onContextMenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener('contextmenu', onContextMenu, false);\n\n\tscope.domElement.addEventListener('mousedown', onMouseDown, false);\n\tscope.domElement.addEventListener('wheel', onMouseWheel, false);\n\n\tscope.domElement.addEventListener('touchstart', onTouchStart, false);\n\tscope.domElement.addEventListener('touchend', onTouchEnd, false);\n\tscope.domElement.addEventListener('touchmove', onTouchMove, false);\n\n\twindow.addEventListener('keydown', onKeyDown, false);\n\n\t// force an update at start\n\n\tthis.update();\n};\n\nTHREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\nObject.defineProperties(THREE.OrbitControls.prototype, {\n\n\tcenter: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .center has been renamed to .target');\n\t\t\treturn this.target;\n\t\t}\n\n\t},\n\n\t// backward compatibility\n\n\tnoZoom: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n\t\t\treturn !this.enableZoom;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n\t\t\tthis.enableZoom = !value;\n\t\t}\n\n\t},\n\n\tnoRotate: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n\t\t\treturn !this.enableRotate;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n\t\t\tthis.enableRotate = !value;\n\t\t}\n\n\t},\n\n\tnoPan: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n\t\t\treturn !this.enablePan;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n\t\t\tthis.enablePan = !value;\n\t\t}\n\n\t},\n\n\tnoKeys: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n\t\t\treturn !this.enableKeys;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n\t\t\tthis.enableKeys = !value;\n\t\t}\n\n\t},\n\n\tstaticMoving: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n\t\t\treturn !this.enableDamping;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n\t\t\tthis.enableDamping = !value;\n\t\t}\n\n\t},\n\n\tdynamicDampingFactor: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n\t\t\treturn this.dampingFactor;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n\t\t\tthis.dampingFactor = value;\n\t\t}\n\n\t}\n\n});\n\n//# sourceURL=webpack:///./src/OrbitControls.js?");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FABRIK_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FABRIK.js */ \"./src/FABRIK.js\");\n/* harmony import */ var _FABRIK_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_FABRIK_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLTFLoader.js */ \"./src/GLTFLoader.js\");\n/* harmony import */ var _GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _OrbitControls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OrbitControls.js */ \"./src/OrbitControls.js\");\n/* harmony import */ var _OrbitControls_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_OrbitControls_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nvar THREE = window.THREE;\nvar raycaster = new THREE.Raycaster();\nvar scene = new THREE.Scene();\nvar camera = new THREE.PerspectiveCamera(22, window.innerWidth / window.innerHeight, 0.1, 1000);\ncamera.position.set(-20, 2, -20);\nvar renderer = new THREE.WebGLRenderer();\nrenderer.setPixelRatio(window.devicePixelRatio);\nrenderer.setClearColor(0x1B8547);\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\nvar light = new THREE.DirectionalLight(0xffffff, 1);\nlight.position.set(0, 1, 0.5);\n\nvar controls = new THREE.OrbitControls(camera, renderer.domElement);\ncontrols.autoRotate = true;\ncontrols.autoRotateSpeed = 0.033;\ncontrols.enableDamping = true;\ncontrols.rotateSpeed = 0.3;\ncontrols.dampingFactor = 0.1;\ncontrols.enablePan = false;\ncontrols.enableZoom = false;\n\nvar dog, skele, bones;\nvar iks = {};\n\nvar boneID = {\n\t\"Pelvis\": 0,\n\t\"Tail_0\": 1, \"Tail_1\": 2, \"Tail_2\": 3, \"Tail_3\": 4,\n\t\"Spine\": 5,\n\t\"Shoulder\": 6, \"Neck\": 7, \"Head\": 8,\n\t\"JawU_0\": 9, \"JawU_1\": 10,\n\t\"JawL_0\": 11, \"JawL_1\": 12,\n\t\"EarL_0\": 13, \"EarL_1\": 14,\n\t\"EarR_0\": 15, \"EarR_1\": 16,\n\t\"ArmL_0\": 17, \"ArmL_1\": 18, \"ArmL_2\": 19, \"ArmL_3\": 20,\n\t\"ArmR_0\": 21, \"ArmR_1\": 22, \"ArmR_2\": 23, \"ArmR_3\": 24,\n\t\"LegL_0\": 25, \"LegL_1\": 26, \"LegL_2\": 27, \"LegL_3\": 28, \"LegL_4\": 29,\n\t\"LegR_0\": 30, \"LegR_1\": 31, \"LegR_2\": 32, \"LegR_3\": 33, \"LegR_4\": 34\n};\nvar pose = {\n\n\treset(lerp = 1) {\n\n\t\tbones.forEach(b => {\n\n\t\t\tb.quaternion.slerp(b.userData.original.quaternion, lerp);\n\t\t});\n\t},\n\n\tvleg(lerp = 1) {\n\n\t\tvar a = -1.335; // leg turns towards belly\n\t\tvar b = -0.35; // body incline -- Pelvis\n\t\tvar b2 = b * -0.5; // body incline -- Shoulder\n\t\tvar c = 0.3; // arm outward reach\n\t\tvar d = -0.65; // arm forward reach\n\t\tvar e = 0.5; // elbow rotation\n\t\tvar f = -0.8; // paw upward rotation\n\t\tvar g = -0.2; // paw tilt\n\n\t\tbones[boneID.LegL_0].rotation.x = THREE.Math.lerp(bones[boneID.LegL_0].rotation.x, a, lerp);\n\t\tbones[boneID.LegR_0].rotation.x = THREE.Math.lerp(bones[boneID.LegR_0].rotation.x, a, lerp);\n\t\tbones[boneID.Pelvis].rotation.x = THREE.Math.lerp(bones[boneID.Pelvis].rotation.x, b, lerp);\n\t\tbones[boneID.Shoulder].rotation.x = THREE.Math.lerp(bones[boneID.Shoulder].rotation.x, b2, lerp);\n\t\tbones[boneID.ArmL_0].rotation.y = THREE.Math.lerp(bones[boneID.ArmL_0].rotation.y, c, lerp);\n\t\tbones[boneID.ArmR_0].rotation.y = THREE.Math.lerp(bones[boneID.ArmR_0].rotation.y, -c, lerp);\n\t\tbones[boneID.ArmL_0].rotation.x = THREE.Math.lerp(bones[boneID.ArmL_0].rotation.x, d, lerp);\n\t\tbones[boneID.ArmR_0].rotation.x = THREE.Math.lerp(bones[boneID.ArmR_0].rotation.x, d, lerp);\n\t\tbones[boneID.ArmL_1].rotation.z = THREE.Math.lerp(bones[boneID.ArmL_1].rotation.z, e, lerp);\n\t\tbones[boneID.ArmR_1].rotation.z = THREE.Math.lerp(bones[boneID.ArmR_1].rotation.z, -e, lerp);\n\t\tbones[boneID.ArmL_2].rotation.x = THREE.Math.lerp(bones[boneID.ArmL_2].rotation.x, f, lerp);\n\t\tbones[boneID.ArmR_2].rotation.x = THREE.Math.lerp(bones[boneID.ArmR_2].rotation.x, f, lerp);\n\t\tbones[boneID.ArmL_2].rotation.z = THREE.Math.lerp(bones[boneID.ArmL_2].rotation.z, g, lerp);\n\t\tbones[boneID.ArmR_2].rotation.z = THREE.Math.lerp(bones[boneID.ArmR_2].rotation.z, -g, lerp);\n\t},\n\n\topenMouth(lerp = 1) {\n\n\t\tbones[boneID.JawL_0].rotation.x = THREE.Math.lerp(bones[boneID.JawL_0].rotation.x, -1.0, lerp);\n\t\tbones[boneID.JawU_0].rotation.x = THREE.Math.lerp(bones[boneID.JawU_0].rotation.x, -0.1, lerp);\n\t\tconstraints[4].offset.x = THREE.Math.lerp(constraints[4].offset.x, 0.1, lerp);\n\t},\n\n\tcloseMouth(lerp = 1) {\n\n\t\tbones[boneID.JawL_0].rotation.x = THREE.Math.lerp(bones[boneID.JawL_0].rotation.x, -0.25, lerp);\n\t\tbones[boneID.JawU_0].rotation.x = THREE.Math.lerp(bones[boneID.JawU_0].rotation.x, -0.22, lerp);\n\t\tconstraints[4].offset.x = THREE.Math.lerp(constraints[4].offset.x, -0.1, lerp);\n\t}\n};\nvar constraints = [{\n\tbone: boneID.Pelvis,\n\tmin: new THREE.Vector3(-0.3, -0.4, -0.0),\n\tmax: new THREE.Vector3(0.3, 0.4, 0.0)\n}, {\n\tbone: boneID.Spine,\n\tmin: new THREE.Vector3(-0.3, -0.4, -0.0),\n\tmax: new THREE.Vector3(0.3, 0.4, 0.0)\n}, {\n\tbone: boneID.Shoulder,\n\tmin: new THREE.Vector3(-0.3, -0.4, -0.2),\n\tmax: new THREE.Vector3(0.3, 0.4, 0.2)\n}, {\n\tbone: boneID.Neck,\n\tmin: new THREE.Vector3(-0.5, -0.8, -0.7),\n\tmax: new THREE.Vector3(0.5, 0.8, 0.7)\n}, {\n\tbone: boneID.Head,\n\tmin: new THREE.Vector3(-0.3, -0.1, -0.3),\n\tmax: new THREE.Vector3(0.3, 0.1, 0.3),\n\toffset: new THREE.Vector3(-0.1, 0, 0)\n}];\n\nvar loader = new THREE.GLTFLoader();\nloader.load(\"./model/wt.glb\", function (gltf) {\n\n\tscene = gltf.scene;\n\t// floor = new THREE.Mesh(new THREE.PlaneGeometry(8,8,8),new THREE.MeshBasicMaterial({color:0xFFFFFF,side:THREE.DoubleSide})); // 0x1B8547\n\t// floor.rotateX(Math.PI / -2)\n\t// scene.add( floor )\n\tscene.add(light);\n\tdog = scene.getObjectByName(\"Mesh\");\n\tdog.position.y = -0.4;\n\tskele = dog.skeleton;\n\tbones = skele.bones;\n\tbones.forEach(b => {\n\n\t\tb.userData.original = {\n\t\t\tquaternion: b.quaternion.clone()\n\t\t};\n\t});\n\n\t// Correct material\n\tdog.material.map.encoding = THREE.LinearEncoding;\n\tvar mat = new THREE.MeshLambertMaterial({\n\t\tcolor: 0x444444,\n\t\tmap: dog.material.map,\n\t\tskinning: true,\n\t\temissive: 0xFFFFFF,\n\t\temissiveMap: dog.material.map\n\t\t// side: THREE.BackSide\n\t});\n\tdog.material = mat;\n\n\t// IK\n\tscene.updateMatrixWorld();\n\tiks.head = new THREE.FABRIK([bones[boneID.Neck], bones[boneID.Head]]);\n}, function (xhr) {\n\n\tconsole.log(xhr.loaded / xhr.total * 100 + \"% loaded\");\n}, function (error) {\n\n\tconsole.log(\"An error happened\", error);\n});\n\n// onEnterFrame\n\nfunction animate() {\n\n\tvar time = Date.now() * 0.01;\n\tif (dog) {\n\n\t\t// calculate target\n\t\tiks.head.refs.target.position.lerp(camera.position.clone().add(new THREE.Vector3(mouse.x * 5 * camera.aspect, mouse.y * 5, -25).applyQuaternion(camera.quaternion)), 0.1);\n\n\t\tconst v = new THREE.Vector3().subVectors(iks.head.target, iks.head.joints[0]);\n\t\tconst v2 = new THREE.Vector3().subVectors(iks.head.target, bones[boneID.Spine].getWorldPosition());\n\t\tconst dBody = Math.min(v2.length(), v.length());\n\n\t\t// neck-head IK\n\t\tiks.head.refresh();\n\t\tiks.head.solve();\n\t\tiks.head.apply(THREE.Math.clamp(THREE.Math.mapLinear(dBody, 1, 10, 0.2, 0), 0, 0.2));\n\n\t\t// Bone limits\n\t\tconstraints.forEach(set => {\n\n\t\t\tconst bone = bones[set.bone];\n\n\t\t\tif (set.min) {\n\n\t\t\t\tconst min = set.min;\n\t\t\t\tbone.rotation.x = Math.max(min.x, bone.rotation.x);\n\t\t\t\tbone.rotation.y = Math.max(min.y, bone.rotation.y);\n\t\t\t\tbone.rotation.z = Math.max(min.z, bone.rotation.z);\n\t\t\t}\n\t\t\tif (set.max) {\n\n\t\t\t\tconst max = set.max;\n\t\t\t\tbone.rotation.x = Math.min(max.x, bone.rotation.x);\n\t\t\t\tbone.rotation.y = Math.min(max.y, bone.rotation.y);\n\t\t\t\tbone.rotation.z = Math.min(max.z, bone.rotation.z);\n\t\t\t}\n\t\t\tif (set.offset) {\n\n\t\t\t\tconst o = set.offset;\n\t\t\t\tbone.rotateX(o.x);\n\t\t\t\tbone.rotateY(o.y);\n\t\t\t\tbone.rotateZ(o.z);\n\t\t\t}\n\t\t});\n\n\t\tif (mouse.isDown && dBody < 6) {\n\n\t\t\tpose.openMouth(0.35);\n\t\t}\n\n\t\t// if ( v.y < - 0.5 && v.z < 1 && v.length() < 5 ) {\n\t\tif (mouse.y < 0 && v.length() < 5) {\n\n\t\t\tpose.vleg(0.10);\n\t\t} else if (v.y > 0.7) {\n\n\t\t\tpose.reset(0.1);\n\t\t}\n\n\t\tlet waggingAmount = THREE.Math.clamp(THREE.Math.mapLinear(dBody, 3, 9, 1, 0), 0, 1);\n\t\tlet waggingTimeFactor = 1;\n\n\t\tif (mouse.isDown) {\n\n\t\t\t// raycast\n\t\t\traycaster.setFromCamera(mouse, camera);\n\t\t\tconst intersects = raycaster.intersectObject(dog, true);\n\t\t\tconst intersect = intersects[0];\n\n\t\t\tif (intersect) {\n\n\t\t\t\tconst p = intersect.point;\n\n\t\t\t\tif (bones[boneID.Tail_2].getWorldPosition().distanceTo(p) < 3) {\n\n\t\t\t\t\twaggingAmount *= 1.8;\n\t\t\t\t\twaggingTimeFactor *= 1.8;\n\t\t\t\t}\n\n\t\t\t\tif (bones[boneID.EarL_0].getWorldPosition().distanceTo(p) < 1.5) {\n\n\t\t\t\t\tbones[boneID.EarL_0].rotation.y = 0.596 + THREE.Math.degToRad(Math.cos(time * 4) * 10);\n\t\t\t\t} else if (bones[boneID.EarR_0].getWorldPosition().distanceTo(p) < 1.5) {\n\n\t\t\t\t\tbones[boneID.EarR_0].rotation.y = -0.596 - THREE.Math.degToRad(Math.cos(time * 4) * 10);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tpose.closeMouth(0.35);\n\t\t}\n\n\t\t// Wagging\n\t\tbones[boneID.Tail_0].rotation.y = THREE.Math.lerp(bones[boneID.Tail_0].rotation.y, THREE.Math.degToRad(Math.sin(time * waggingTimeFactor) * 5 * waggingAmount), 0.2);\n\t\tbones[boneID.Tail_1].rotation.y = THREE.Math.lerp(bones[boneID.Tail_1].rotation.y, THREE.Math.degToRad(Math.sin(time * waggingTimeFactor) * -20 * waggingAmount), 0.2);\n\t\tbones[boneID.Tail_2].rotation.y = THREE.Math.lerp(bones[boneID.Tail_2].rotation.y, THREE.Math.degToRad(Math.sin(time * waggingTimeFactor) * -30 * waggingAmount), 0.2);\n\t}\n\tcontrols.update();\n\trenderer.render(scene, camera);\n\trequestAnimationFrame(animate);\n}\nanimate();\n\n// resize\n\nwindow.addEventListener(\"resize\", function () {\n\n\tvar w = window.innerWidth;\n\tvar h = window.innerHeight;\n\tcamera.aspect = w / h;\n\tcamera.updateProjectionMatrix();\n\trenderer.setSize(w, h);\n});\n\n// mouse\nvar mouse = { x: 0, y: 0, isDown: false };\nwindow.addEventListener(\"mousemove\", function (evt) {\n\n\tmouse.x = evt.clientX / window.innerWidth * 2 - 1;\n\tmouse.y = -(evt.clientY / window.innerHeight) * 2 + 1;\n});\nwindow.addEventListener(\"mousedown\", function (evt) {\n\n\tmouse.isDown = true;\n});\nwindow.addEventListener(\"mouseup\", function (evt) {\n\n\tmouse.isDown = false;\n});\nwindow.addEventListener(\"touchstart\", function (evt) {\n\n\tmouse.isDown = true;\n});\nwindow.addEventListener(\"touchend\", function (evt) {\n\n\tmouse.isDown = false;\n});\nwindow.addEventListener(\"mouseout\", function (evt) {\n\n\tmouse.isDown = false;\n});\n\n//# sourceURL=webpack:///./src/script.js?");

/***/ })

/******/ });